##
## Entitas Generated Entity Extensions for shmupwarz
##
## do not edit this file
##
import queues
import bosco/ECS
import bosco/Sprite
import ComponentEx
const POOL_SIZE : int = 128


type TPool = ref object
  ## @type {entitas.utils.Bag}
  boundsComponentPool* : Queue[BoundsComponent]
  ## @type {shmupwarz.BulletComponent}
  bulletComponent* : BulletComponent
  ## @type {entitas.utils.Bag}
  colorAnimationComponentPool* : Queue[ColorAnimationComponent]
  ## @type {shmupwarz.DestroyComponent}
  destroyComponent* : DestroyComponent
  ## @type {shmupwarz.EnemyComponent}
  enemyComponent* : EnemyComponent
  ## @type {entitas.utils.Bag}
  expiresComponentPool* : Queue[ExpiresComponent]
  ## @type {shmupwarz.FiringComponent}
  firingComponent* : FiringComponent
  ## @type {entitas.utils.Bag}
  healthComponentPool* : Queue[HealthComponent]
  ## @type {entitas.utils.Bag}
  layerComponentPool* : Queue[LayerComponent]
  ## @type {entitas.utils.Bag}
  lifeComponentPool* : Queue[LifeComponent]
  ## @type {shmupwarz.MineComponent}
  mineComponent* : MineComponent
  ## @type {entitas.utils.Bag}
  mouseComponentPool* : Queue[MouseComponent]
  ## @type {shmupwarz.PlayerComponent}
  playerComponent* : PlayerComponent
  ## @type {entitas.utils.Bag}
  positionComponentPool* : Queue[PositionComponent]
  ## @type {entitas.utils.Bag}
  resourceComponentPool* : Queue[ResourceComponent]
  ## @type {entitas.utils.Bag}
  scaleAnimationComponentPool* : Queue[ScaleAnimationComponent]
  ## @type {entitas.utils.Bag}
  scaleComponentPool* : Queue[ScaleComponent]
  ## @type {entitas.utils.Bag}
  scoreComponentPool* : Queue[ScoreComponent]
  ## @type {entitas.utils.Bag}
  soundEffectComponentPool* : Queue[SoundEffectComponent]
  ## @type {entitas.utils.Bag}
  velocityComponentPool* : Queue[VelocityComponent]
var Pool* = TPool()
#Pool.{name}ComponentPool = initQueue[Entity]()
Pool.boundsComponentPool = initQueue[BoundsComponent]()
for i in 1..POOL_SIZE:
  Pool.boundsComponentPool.add(BoundsComponent())
Pool.bulletComponent = BulletComponent()
#Pool.{name}ComponentPool = initQueue[Entity]()
Pool.colorAnimationComponentPool = initQueue[ColorAnimationComponent]()
for i in 1..POOL_SIZE:
  Pool.colorAnimationComponentPool.add(ColorAnimationComponent())
Pool.destroyComponent = DestroyComponent()
Pool.enemyComponent = EnemyComponent()
#Pool.{name}ComponentPool = initQueue[Entity]()
Pool.expiresComponentPool = initQueue[ExpiresComponent]()
for i in 1..POOL_SIZE:
  Pool.expiresComponentPool.add(ExpiresComponent())
Pool.firingComponent = FiringComponent()
#Pool.{name}ComponentPool = initQueue[Entity]()
Pool.healthComponentPool = initQueue[HealthComponent]()
for i in 1..POOL_SIZE:
  Pool.healthComponentPool.add(HealthComponent())
#Pool.{name}ComponentPool = initQueue[Entity]()
Pool.layerComponentPool = initQueue[LayerComponent]()
for i in 1..POOL_SIZE:
  Pool.layerComponentPool.add(LayerComponent())
#Pool.{name}ComponentPool = initQueue[Entity]()
Pool.lifeComponentPool = initQueue[LifeComponent]()
for i in 1..POOL_SIZE:
  Pool.lifeComponentPool.add(LifeComponent())
Pool.mineComponent = MineComponent()
#Pool.{name}ComponentPool = initQueue[Entity]()
Pool.mouseComponentPool = initQueue[MouseComponent]()
for i in 1..POOL_SIZE:
  Pool.mouseComponentPool.add(MouseComponent())
Pool.playerComponent = PlayerComponent()
#Pool.{name}ComponentPool = initQueue[Entity]()
Pool.positionComponentPool = initQueue[PositionComponent]()
for i in 1..POOL_SIZE:
  Pool.positionComponentPool.add(PositionComponent())
#Pool.{name}ComponentPool = initQueue[Entity]()
Pool.resourceComponentPool = initQueue[ResourceComponent]()
for i in 1..POOL_SIZE:
  Pool.resourceComponentPool.add(ResourceComponent())
#Pool.{name}ComponentPool = initQueue[Entity]()
Pool.scaleAnimationComponentPool = initQueue[ScaleAnimationComponent]()
for i in 1..POOL_SIZE:
  Pool.scaleAnimationComponentPool.add(ScaleAnimationComponent())
#Pool.{name}ComponentPool = initQueue[Entity]()
Pool.scaleComponentPool = initQueue[ScaleComponent]()
for i in 1..POOL_SIZE:
  Pool.scaleComponentPool.add(ScaleComponent())
#Pool.{name}ComponentPool = initQueue[Entity]()
Pool.scoreComponentPool = initQueue[ScoreComponent]()
for i in 1..POOL_SIZE:
  Pool.scoreComponentPool.add(ScoreComponent())
#Pool.{name}ComponentPool = initQueue[Entity]()
Pool.soundEffectComponentPool = initQueue[SoundEffectComponent]()
for i in 1..POOL_SIZE:
  Pool.soundEffectComponentPool.add(SoundEffectComponent())
#Pool.{name}ComponentPool = initQueue[Entity]()
Pool.velocityComponentPool = initQueue[VelocityComponent]()
for i in 1..POOL_SIZE:
  Pool.velocityComponentPool.add(VelocityComponent())


proc clearBoundsComponentPool*(this : Entity) =
  Pool.boundsComponentPool = initQueue[BoundsComponent]()

## @type {shmupwarz.BoundsComponent} 
proc bounds*(this : Entity) : BoundsComponent =
  (BoundsComponent)this.getComponent(int(Component.Bounds))

## @type {boolean} 
proc hasBounds*(this : Entity) : bool =
  this.hasComponent(int(Component.Bounds))

##
## @param {float64} radius
## @returns {entitas.Entity}
##
proc addBounds*(this : Entity, radius:float64) : Entity =
  var component = if Pool.boundsComponentPool.len > 0 : Pool.boundsComponentPool.dequeue() else: BoundsComponent()
  component.radius = radius
  discard this.addComponent(int(Component.Bounds), component)
  return this

##
## @param {float64} radius
## @returns {entitas.Entity}
##
proc replaceBounds*(this : Entity, radius:float64) : Entity =
  var previousComponent = if this.hasBounds : this.bounds else: nil
  var component = if Pool.boundsComponentPool.len > 0 : Pool.boundsComponentPool.dequeue() else: BoundsComponent()
  component.radius = radius
  discard this.replaceComponent(int(Component.Bounds), component)
  if previousComponent != nil:
    Pool.boundsComponentPool.enqueue(previousComponent)

  return this

##
## @returns {entitas.Entity}
##
proc removeBounds*(this : Entity) : Entity =
  var component = this.bounds
  discard this.removeComponent(int(Component.Bounds))
  Pool.boundsComponentPool.enqueue(component)
  return this

## @type {boolean} 
proc isBullet*(this : Entity) : bool =
  this.hasComponent(int(Component.Bullet))
proc `isBullet=`*(this : Entity, value : bool) =
  if value != this.isBullet:
    if value:
      discard this.addComponent(int(Component.Bullet), Pool.bulletComponent)
    else:
      discard this.removeComponent(int(Component.Bullet))

##
## @param {boolean} value
## @returns {entitas.Entity}
##
proc setBullet*(this : Entity, value : bool) : Entity =
  this.isBullet = value
  return this


proc clearColorAnimationComponentPool*(this : Entity) =
  Pool.colorAnimationComponentPool = initQueue[ColorAnimationComponent]()

## @type {shmupwarz.ColorAnimationComponent} 
proc colorAnimation*(this : Entity) : ColorAnimationComponent =
  (ColorAnimationComponent)this.getComponent(int(Component.ColorAnimation))

## @type {boolean} 
proc hasColorAnimation*(this : Entity) : bool =
  this.hasComponent(int(Component.ColorAnimation))

##
## @param {float64} redMin
## @param {float64} redMax
## @param {float64} redSpeed
## @param {float64} greenMin
## @param {float64} greenMax
## @param {float64} greenSpeed
## @param {float64} blueMin
## @param {float64} blueMax
## @param {float64} blueSpeed
## @param {float64} alphaMin
## @param {float64} alphaMax
## @param {float64} alphaSpeed
## @param {bool} redAnimate
## @param {bool} greenAnimate
## @param {bool} blueAnimate
## @param {bool} alphaAnimate
## @param {bool} repeat
## @returns {entitas.Entity}
##
proc addColorAnimation*(this : Entity, redMin:float64, redMax:float64, redSpeed:float64, greenMin:float64, greenMax:float64, greenSpeed:float64, blueMin:float64, blueMax:float64, blueSpeed:float64, alphaMin:float64, alphaMax:float64, alphaSpeed:float64, redAnimate:bool, greenAnimate:bool, blueAnimate:bool, alphaAnimate:bool, repeat:bool) : Entity =
  var component = if Pool.colorAnimationComponentPool.len > 0 : Pool.colorAnimationComponentPool.dequeue() else: ColorAnimationComponent()
  component.redMin = redMin
  component.redMax = redMax
  component.redSpeed = redSpeed
  component.greenMin = greenMin
  component.greenMax = greenMax
  component.greenSpeed = greenSpeed
  component.blueMin = blueMin
  component.blueMax = blueMax
  component.blueSpeed = blueSpeed
  component.alphaMin = alphaMin
  component.alphaMax = alphaMax
  component.alphaSpeed = alphaSpeed
  component.redAnimate = redAnimate
  component.greenAnimate = greenAnimate
  component.blueAnimate = blueAnimate
  component.alphaAnimate = alphaAnimate
  component.repeat = repeat
  discard this.addComponent(int(Component.ColorAnimation), component)
  return this

##
## @param {float64} redMin
## @param {float64} redMax
## @param {float64} redSpeed
## @param {float64} greenMin
## @param {float64} greenMax
## @param {float64} greenSpeed
## @param {float64} blueMin
## @param {float64} blueMax
## @param {float64} blueSpeed
## @param {float64} alphaMin
## @param {float64} alphaMax
## @param {float64} alphaSpeed
## @param {bool} redAnimate
## @param {bool} greenAnimate
## @param {bool} blueAnimate
## @param {bool} alphaAnimate
## @param {bool} repeat
## @returns {entitas.Entity}
##
proc replaceColorAnimation*(this : Entity, redMin:float64, redMax:float64, redSpeed:float64, greenMin:float64, greenMax:float64, greenSpeed:float64, blueMin:float64, blueMax:float64, blueSpeed:float64, alphaMin:float64, alphaMax:float64, alphaSpeed:float64, redAnimate:bool, greenAnimate:bool, blueAnimate:bool, alphaAnimate:bool, repeat:bool) : Entity =
  var previousComponent = if this.hasColorAnimation : this.colorAnimation else: nil
  var component = if Pool.colorAnimationComponentPool.len > 0 : Pool.colorAnimationComponentPool.dequeue() else: ColorAnimationComponent()
  component.redMin = redMin
  component.redMax = redMax
  component.redSpeed = redSpeed
  component.greenMin = greenMin
  component.greenMax = greenMax
  component.greenSpeed = greenSpeed
  component.blueMin = blueMin
  component.blueMax = blueMax
  component.blueSpeed = blueSpeed
  component.alphaMin = alphaMin
  component.alphaMax = alphaMax
  component.alphaSpeed = alphaSpeed
  component.redAnimate = redAnimate
  component.greenAnimate = greenAnimate
  component.blueAnimate = blueAnimate
  component.alphaAnimate = alphaAnimate
  component.repeat = repeat
  discard this.replaceComponent(int(Component.ColorAnimation), component)
  if previousComponent != nil:
    Pool.colorAnimationComponentPool.enqueue(previousComponent)

  return this

##
## @returns {entitas.Entity}
##
proc removeColorAnimation*(this : Entity) : Entity =
  var component = this.colorAnimation
  discard this.removeComponent(int(Component.ColorAnimation))
  Pool.colorAnimationComponentPool.enqueue(component)
  return this

## @type {boolean} 
proc isDestroy*(this : Entity) : bool =
  this.hasComponent(int(Component.Destroy))
proc `isDestroy=`*(this : Entity, value : bool) =
  if value != this.isDestroy:
    if value:
      discard this.addComponent(int(Component.Destroy), Pool.destroyComponent)
    else:
      discard this.removeComponent(int(Component.Destroy))

##
## @param {boolean} value
## @returns {entitas.Entity}
##
proc setDestroy*(this : Entity, value : bool) : Entity =
  this.isDestroy = value
  return this

## @type {boolean} 
proc isEnemy*(this : Entity) : bool =
  this.hasComponent(int(Component.Enemy))
proc `isEnemy=`*(this : Entity, value : bool) =
  if value != this.isEnemy:
    if value:
      discard this.addComponent(int(Component.Enemy), Pool.enemyComponent)
    else:
      discard this.removeComponent(int(Component.Enemy))

##
## @param {boolean} value
## @returns {entitas.Entity}
##
proc setEnemy*(this : Entity, value : bool) : Entity =
  this.isEnemy = value
  return this


proc clearExpiresComponentPool*(this : Entity) =
  Pool.expiresComponentPool = initQueue[ExpiresComponent]()

## @type {shmupwarz.ExpiresComponent} 
proc expires*(this : Entity) : ExpiresComponent =
  (ExpiresComponent)this.getComponent(int(Component.Expires))

## @type {boolean} 
proc hasExpires*(this : Entity) : bool =
  this.hasComponent(int(Component.Expires))

##
## @param {float64} delay
## @returns {entitas.Entity}
##
proc addExpires*(this : Entity, delay:float64) : Entity =
  var component = if Pool.expiresComponentPool.len > 0 : Pool.expiresComponentPool.dequeue() else: ExpiresComponent()
  component.delay = delay
  discard this.addComponent(int(Component.Expires), component)
  return this

##
## @param {float64} delay
## @returns {entitas.Entity}
##
proc replaceExpires*(this : Entity, delay:float64) : Entity =
  var previousComponent = if this.hasExpires : this.expires else: nil
  var component = if Pool.expiresComponentPool.len > 0 : Pool.expiresComponentPool.dequeue() else: ExpiresComponent()
  component.delay = delay
  discard this.replaceComponent(int(Component.Expires), component)
  if previousComponent != nil:
    Pool.expiresComponentPool.enqueue(previousComponent)

  return this

##
## @returns {entitas.Entity}
##
proc removeExpires*(this : Entity) : Entity =
  var component = this.expires
  discard this.removeComponent(int(Component.Expires))
  Pool.expiresComponentPool.enqueue(component)
  return this

## @type {boolean} 
proc isFiring*(this : Entity) : bool =
  this.hasComponent(int(Component.Firing))
proc `isFiring=`*(this : Entity, value : bool) =
  if value != this.isFiring:
    if value:
      discard this.addComponent(int(Component.Firing), Pool.firingComponent)
    else:
      discard this.removeComponent(int(Component.Firing))

##
## @param {boolean} value
## @returns {entitas.Entity}
##
proc setFiring*(this : Entity, value : bool) : Entity =
  this.isFiring = value
  return this


proc clearHealthComponentPool*(this : Entity) =
  Pool.healthComponentPool = initQueue[HealthComponent]()

## @type {shmupwarz.HealthComponent} 
proc health*(this : Entity) : HealthComponent =
  (HealthComponent)this.getComponent(int(Component.Health))

## @type {boolean} 
proc hasHealth*(this : Entity) : bool =
  this.hasComponent(int(Component.Health))

##
## @param {float64} health
## @param {float64} maximumHealth
## @returns {entitas.Entity}
##
proc addHealth*(this : Entity, health:float64, maximumHealth:float64) : Entity =
  var component = if Pool.healthComponentPool.len > 0 : Pool.healthComponentPool.dequeue() else: HealthComponent()
  component.health = health
  component.maximumHealth = maximumHealth
  discard this.addComponent(int(Component.Health), component)
  return this

##
## @param {float64} health
## @param {float64} maximumHealth
## @returns {entitas.Entity}
##
proc replaceHealth*(this : Entity, health:float64, maximumHealth:float64) : Entity =
  var previousComponent = if this.hasHealth : this.health else: nil
  var component = if Pool.healthComponentPool.len > 0 : Pool.healthComponentPool.dequeue() else: HealthComponent()
  component.health = health
  component.maximumHealth = maximumHealth
  discard this.replaceComponent(int(Component.Health), component)
  if previousComponent != nil:
    Pool.healthComponentPool.enqueue(previousComponent)

  return this

##
## @returns {entitas.Entity}
##
proc removeHealth*(this : Entity) : Entity =
  var component = this.health
  discard this.removeComponent(int(Component.Health))
  Pool.healthComponentPool.enqueue(component)
  return this


proc clearLayerComponentPool*(this : Entity) =
  Pool.layerComponentPool = initQueue[LayerComponent]()

## @type {shmupwarz.LayerComponent} 
proc layer*(this : Entity) : LayerComponent =
  (LayerComponent)this.getComponent(int(Component.Layer))

## @type {boolean} 
proc hasLayer*(this : Entity) : bool =
  this.hasComponent(int(Component.Layer))

##
## @param {int} ordinal
## @returns {entitas.Entity}
##
proc addLayer*(this : Entity, ordinal:int) : Entity =
  var component = if Pool.layerComponentPool.len > 0 : Pool.layerComponentPool.dequeue() else: LayerComponent()
  component.ordinal = ordinal
  discard this.addComponent(int(Component.Layer), component)
  return this

##
## @param {int} ordinal
## @returns {entitas.Entity}
##
proc replaceLayer*(this : Entity, ordinal:int) : Entity =
  var previousComponent = if this.hasLayer : this.layer else: nil
  var component = if Pool.layerComponentPool.len > 0 : Pool.layerComponentPool.dequeue() else: LayerComponent()
  component.ordinal = ordinal
  discard this.replaceComponent(int(Component.Layer), component)
  if previousComponent != nil:
    Pool.layerComponentPool.enqueue(previousComponent)

  return this

##
## @returns {entitas.Entity}
##
proc removeLayer*(this : Entity) : Entity =
  var component = this.layer
  discard this.removeComponent(int(Component.Layer))
  Pool.layerComponentPool.enqueue(component)
  return this


proc clearLifeComponentPool*(this : Entity) =
  Pool.lifeComponentPool = initQueue[LifeComponent]()

## @type {shmupwarz.LifeComponent} 
proc life*(this : Entity) : LifeComponent =
  (LifeComponent)this.getComponent(int(Component.Life))

## @type {boolean} 
proc hasLife*(this : Entity) : bool =
  this.hasComponent(int(Component.Life))

##
## @param {int} count
## @returns {entitas.Entity}
##
proc addLife*(this : Entity, count:int) : Entity =
  var component = if Pool.lifeComponentPool.len > 0 : Pool.lifeComponentPool.dequeue() else: LifeComponent()
  component.count = count
  discard this.addComponent(int(Component.Life), component)
  return this

##
## @param {int} count
## @returns {entitas.Entity}
##
proc replaceLife*(this : Entity, count:int) : Entity =
  var previousComponent = if this.hasLife : this.life else: nil
  var component = if Pool.lifeComponentPool.len > 0 : Pool.lifeComponentPool.dequeue() else: LifeComponent()
  component.count = count
  discard this.replaceComponent(int(Component.Life), component)
  if previousComponent != nil:
    Pool.lifeComponentPool.enqueue(previousComponent)

  return this

##
## @returns {entitas.Entity}
##
proc removeLife*(this : Entity) : Entity =
  var component = this.life
  discard this.removeComponent(int(Component.Life))
  Pool.lifeComponentPool.enqueue(component)
  return this

## @type {boolean} 
proc isMine*(this : Entity) : bool =
  this.hasComponent(int(Component.Mine))
proc `isMine=`*(this : Entity, value : bool) =
  if value != this.isMine:
    if value:
      discard this.addComponent(int(Component.Mine), Pool.mineComponent)
    else:
      discard this.removeComponent(int(Component.Mine))

##
## @param {boolean} value
## @returns {entitas.Entity}
##
proc setMine*(this : Entity, value : bool) : Entity =
  this.isMine = value
  return this


proc clearMouseComponentPool*(this : Entity) =
  Pool.mouseComponentPool = initQueue[MouseComponent]()

## @type {shmupwarz.MouseComponent} 
proc mouse*(this : Entity) : MouseComponent =
  (MouseComponent)this.getComponent(int(Component.Mouse))

## @type {boolean} 
proc hasMouse*(this : Entity) : bool =
  this.hasComponent(int(Component.Mouse))

##
## @param {float64} x
## @param {float64} y
## @returns {entitas.Entity}
##
proc addMouse*(this : Entity, x:float64, y:float64) : Entity =
  var component = if Pool.mouseComponentPool.len > 0 : Pool.mouseComponentPool.dequeue() else: MouseComponent()
  component.x = x
  component.y = y
  discard this.addComponent(int(Component.Mouse), component)
  return this

##
## @param {float64} x
## @param {float64} y
## @returns {entitas.Entity}
##
proc replaceMouse*(this : Entity, x:float64, y:float64) : Entity =
  var previousComponent = if this.hasMouse : this.mouse else: nil
  var component = if Pool.mouseComponentPool.len > 0 : Pool.mouseComponentPool.dequeue() else: MouseComponent()
  component.x = x
  component.y = y
  discard this.replaceComponent(int(Component.Mouse), component)
  if previousComponent != nil:
    Pool.mouseComponentPool.enqueue(previousComponent)

  return this

##
## @returns {entitas.Entity}
##
proc removeMouse*(this : Entity) : Entity =
  var component = this.mouse
  discard this.removeComponent(int(Component.Mouse))
  Pool.mouseComponentPool.enqueue(component)
  return this

## @type {boolean} 
proc isPlayer*(this : Entity) : bool =
  this.hasComponent(int(Component.Player))
proc `isPlayer=`*(this : Entity, value : bool) =
  if value != this.isPlayer:
    if value:
      discard this.addComponent(int(Component.Player), Pool.playerComponent)
    else:
      discard this.removeComponent(int(Component.Player))

##
## @param {boolean} value
## @returns {entitas.Entity}
##
proc setPlayer*(this : Entity, value : bool) : Entity =
  this.isPlayer = value
  return this


proc clearPositionComponentPool*(this : Entity) =
  Pool.positionComponentPool = initQueue[PositionComponent]()

## @type {shmupwarz.PositionComponent} 
proc position*(this : Entity) : PositionComponent =
  (PositionComponent)this.getComponent(int(Component.Position))

## @type {boolean} 
proc hasPosition*(this : Entity) : bool =
  this.hasComponent(int(Component.Position))

##
## @param {float64} x
## @param {float64} y
## @returns {entitas.Entity}
##
proc addPosition*(this : Entity, x:float64, y:float64) : Entity =
  var component = if Pool.positionComponentPool.len > 0 : Pool.positionComponentPool.dequeue() else: PositionComponent()
  component.x = x
  component.y = y
  discard this.addComponent(int(Component.Position), component)
  return this

##
## @param {float64} x
## @param {float64} y
## @returns {entitas.Entity}
##
proc replacePosition*(this : Entity, x:float64, y:float64) : Entity =
  var previousComponent = if this.hasPosition : this.position else: nil
  var component = if Pool.positionComponentPool.len > 0 : Pool.positionComponentPool.dequeue() else: PositionComponent()
  component.x = x
  component.y = y
  discard this.replaceComponent(int(Component.Position), component)
  if previousComponent != nil:
    Pool.positionComponentPool.enqueue(previousComponent)

  return this

##
## @returns {entitas.Entity}
##
proc removePosition*(this : Entity) : Entity =
  var component = this.position
  discard this.removeComponent(int(Component.Position))
  Pool.positionComponentPool.enqueue(component)
  return this


proc clearResourceComponentPool*(this : Entity) =
  Pool.resourceComponentPool = initQueue[ResourceComponent]()

## @type {shmupwarz.ResourceComponent} 
proc resource*(this : Entity) : ResourceComponent =
  (ResourceComponent)this.getComponent(int(Component.Resource))

## @type {boolean} 
proc hasResource*(this : Entity) : bool =
  this.hasComponent(int(Component.Resource))

##
## @param {string} path
## @returns {entitas.Entity}
##
proc addResource*(this : Entity, path:string) : Entity =
  var component = if Pool.resourceComponentPool.len > 0 : Pool.resourceComponentPool.dequeue() else: ResourceComponent()
  component.path = path
  discard this.addComponent(int(Component.Resource), component)
  return this

##
## @param {string} path
## @returns {entitas.Entity}
##
proc replaceResource*(this : Entity, path:string) : Entity =
  var previousComponent = if this.hasResource : this.resource else: nil
  var component = if Pool.resourceComponentPool.len > 0 : Pool.resourceComponentPool.dequeue() else: ResourceComponent()
  component.path = path
  discard this.replaceComponent(int(Component.Resource), component)
  if previousComponent != nil:
    Pool.resourceComponentPool.enqueue(previousComponent)

  return this

##
## @returns {entitas.Entity}
##
proc removeResource*(this : Entity) : Entity =
  var component = this.resource
  discard this.removeComponent(int(Component.Resource))
  Pool.resourceComponentPool.enqueue(component)
  return this


proc clearScaleAnimationComponentPool*(this : Entity) =
  Pool.scaleAnimationComponentPool = initQueue[ScaleAnimationComponent]()

## @type {shmupwarz.ScaleAnimationComponent} 
proc scaleAnimation*(this : Entity) : ScaleAnimationComponent =
  (ScaleAnimationComponent)this.getComponent(int(Component.ScaleAnimation))

## @type {boolean} 
proc hasScaleAnimation*(this : Entity) : bool =
  this.hasComponent(int(Component.ScaleAnimation))

##
## @param {float64} min
## @param {float64} max
## @param {float64} speed
## @param {bool} repeat
## @param {bool} active
## @returns {entitas.Entity}
##
proc addScaleAnimation*(this : Entity, min:float64, max:float64, speed:float64, repeat:bool, active:bool) : Entity =
  var component = if Pool.scaleAnimationComponentPool.len > 0 : Pool.scaleAnimationComponentPool.dequeue() else: ScaleAnimationComponent()
  component.min = min
  component.max = max
  component.speed = speed
  component.repeat = repeat
  component.active = active
  discard this.addComponent(int(Component.ScaleAnimation), component)
  return this

##
## @param {float64} min
## @param {float64} max
## @param {float64} speed
## @param {bool} repeat
## @param {bool} active
## @returns {entitas.Entity}
##
proc replaceScaleAnimation*(this : Entity, min:float64, max:float64, speed:float64, repeat:bool, active:bool) : Entity =
  var previousComponent = if this.hasScaleAnimation : this.scaleAnimation else: nil
  var component = if Pool.scaleAnimationComponentPool.len > 0 : Pool.scaleAnimationComponentPool.dequeue() else: ScaleAnimationComponent()
  component.min = min
  component.max = max
  component.speed = speed
  component.repeat = repeat
  component.active = active
  discard this.replaceComponent(int(Component.ScaleAnimation), component)
  if previousComponent != nil:
    Pool.scaleAnimationComponentPool.enqueue(previousComponent)

  return this

##
## @returns {entitas.Entity}
##
proc removeScaleAnimation*(this : Entity) : Entity =
  var component = this.scaleAnimation
  discard this.removeComponent(int(Component.ScaleAnimation))
  Pool.scaleAnimationComponentPool.enqueue(component)
  return this


proc clearScaleComponentPool*(this : Entity) =
  Pool.scaleComponentPool = initQueue[ScaleComponent]()

## @type {shmupwarz.ScaleComponent} 
proc scale*(this : Entity) : ScaleComponent =
  (ScaleComponent)this.getComponent(int(Component.Scale))

## @type {boolean} 
proc hasScale*(this : Entity) : bool =
  this.hasComponent(int(Component.Scale))

##
## @param {float64} x
## @param {float64} y
## @returns {entitas.Entity}
##
proc addScale*(this : Entity, x:float64, y:float64) : Entity =
  var component = if Pool.scaleComponentPool.len > 0 : Pool.scaleComponentPool.dequeue() else: ScaleComponent()
  component.x = x
  component.y = y
  discard this.addComponent(int(Component.Scale), component)
  return this

##
## @param {float64} x
## @param {float64} y
## @returns {entitas.Entity}
##
proc replaceScale*(this : Entity, x:float64, y:float64) : Entity =
  var previousComponent = if this.hasScale : this.scale else: nil
  var component = if Pool.scaleComponentPool.len > 0 : Pool.scaleComponentPool.dequeue() else: ScaleComponent()
  component.x = x
  component.y = y
  discard this.replaceComponent(int(Component.Scale), component)
  if previousComponent != nil:
    Pool.scaleComponentPool.enqueue(previousComponent)

  return this

##
## @returns {entitas.Entity}
##
proc removeScale*(this : Entity) : Entity =
  var component = this.scale
  discard this.removeComponent(int(Component.Scale))
  Pool.scaleComponentPool.enqueue(component)
  return this


proc clearScoreComponentPool*(this : Entity) =
  Pool.scoreComponentPool = initQueue[ScoreComponent]()

## @type {shmupwarz.ScoreComponent} 
proc score*(this : Entity) : ScoreComponent =
  (ScoreComponent)this.getComponent(int(Component.Score))

## @type {boolean} 
proc hasScore*(this : Entity) : bool =
  this.hasComponent(int(Component.Score))

##
## @param {float64} value
## @returns {entitas.Entity}
##
proc addScore*(this : Entity, value:float64) : Entity =
  var component = if Pool.scoreComponentPool.len > 0 : Pool.scoreComponentPool.dequeue() else: ScoreComponent()
  component.value = value
  discard this.addComponent(int(Component.Score), component)
  return this

##
## @param {float64} value
## @returns {entitas.Entity}
##
proc replaceScore*(this : Entity, value:float64) : Entity =
  var previousComponent = if this.hasScore : this.score else: nil
  var component = if Pool.scoreComponentPool.len > 0 : Pool.scoreComponentPool.dequeue() else: ScoreComponent()
  component.value = value
  discard this.replaceComponent(int(Component.Score), component)
  if previousComponent != nil:
    Pool.scoreComponentPool.enqueue(previousComponent)

  return this

##
## @returns {entitas.Entity}
##
proc removeScore*(this : Entity) : Entity =
  var component = this.score
  discard this.removeComponent(int(Component.Score))
  Pool.scoreComponentPool.enqueue(component)
  return this


proc clearSoundEffectComponentPool*(this : Entity) =
  Pool.soundEffectComponentPool = initQueue[SoundEffectComponent]()

## @type {shmupwarz.SoundEffectComponent} 
proc soundEffect*(this : Entity) : SoundEffectComponent =
  (SoundEffectComponent)this.getComponent(int(Component.SoundEffect))

## @type {boolean} 
proc hasSoundEffect*(this : Entity) : bool =
  this.hasComponent(int(Component.SoundEffect))

##
## @param {int} effect
## @returns {entitas.Entity}
##
proc addSoundEffect*(this : Entity, effect:int) : Entity =
  var component = if Pool.soundEffectComponentPool.len > 0 : Pool.soundEffectComponentPool.dequeue() else: SoundEffectComponent()
  component.effect = effect
  discard this.addComponent(int(Component.SoundEffect), component)
  return this

##
## @param {int} effect
## @returns {entitas.Entity}
##
proc replaceSoundEffect*(this : Entity, effect:int) : Entity =
  var previousComponent = if this.hasSoundEffect : this.soundEffect else: nil
  var component = if Pool.soundEffectComponentPool.len > 0 : Pool.soundEffectComponentPool.dequeue() else: SoundEffectComponent()
  component.effect = effect
  discard this.replaceComponent(int(Component.SoundEffect), component)
  if previousComponent != nil:
    Pool.soundEffectComponentPool.enqueue(previousComponent)

  return this

##
## @returns {entitas.Entity}
##
proc removeSoundEffect*(this : Entity) : Entity =
  var component = this.soundEffect
  discard this.removeComponent(int(Component.SoundEffect))
  Pool.soundEffectComponentPool.enqueue(component)
  return this


proc clearVelocityComponentPool*(this : Entity) =
  Pool.velocityComponentPool = initQueue[VelocityComponent]()

## @type {shmupwarz.VelocityComponent} 
proc velocity*(this : Entity) : VelocityComponent =
  (VelocityComponent)this.getComponent(int(Component.Velocity))

## @type {boolean} 
proc hasVelocity*(this : Entity) : bool =
  this.hasComponent(int(Component.Velocity))

##
## @param {float64} x
## @param {float64} y
## @returns {entitas.Entity}
##
proc addVelocity*(this : Entity, x:float64, y:float64) : Entity =
  var component = if Pool.velocityComponentPool.len > 0 : Pool.velocityComponentPool.dequeue() else: VelocityComponent()
  component.x = x
  component.y = y
  discard this.addComponent(int(Component.Velocity), component)
  return this

##
## @param {float64} x
## @param {float64} y
## @returns {entitas.Entity}
##
proc replaceVelocity*(this : Entity, x:float64, y:float64) : Entity =
  var previousComponent = if this.hasVelocity : this.velocity else: nil
  var component = if Pool.velocityComponentPool.len > 0 : Pool.velocityComponentPool.dequeue() else: VelocityComponent()
  component.x = x
  component.y = y
  discard this.replaceComponent(int(Component.Velocity), component)
  if previousComponent != nil:
    Pool.velocityComponentPool.enqueue(previousComponent)

  return this

##
## @returns {entitas.Entity}
##
proc removeVelocity*(this : Entity) : Entity =
  var component = this.velocity
  discard this.removeComponent(int(Component.Velocity))
  Pool.velocityComponentPool.enqueue(component)
  return this


